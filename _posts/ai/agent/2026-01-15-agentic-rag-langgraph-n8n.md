---
title: "[AI Agent] RAG에서 AI 에이전트로: LangGraph와 n8n 활용법"
excerpt: "단순 검색-생성 구조의 Naive RAG를 넘어, 스스로 판단하고 재시도하는 Agentic RAG의 개념과 LangGraph, n8n을 활용한 구현 방법을 정리합니다."
layout: single
categories:
  - ai
  - agent
tags:
  - ai agent
  - rag
  - langgraph
  - n8n
  - langchain
author_profile: false
sidebar:
  nav: "docs"
search: true
toc: true
toc_sticky: true
toc_label: 목차
date: 2026-01-15 00:00:00 +0900
---

단순히 문서를 찾아 답변을 생성하는 시대는 지났다. 이제는 AI가 스스로 생각하고, 부족한 정보를 다시 찾으며, 도구를 사용하는 **'에이전틱 RAG(Agentic RAG)'**의 시대다. 오늘 공부한 핵심 내용을 정리해 본다.

---

## 1. 왜 'RAG 에이전트'인가? (Naive vs Agentic)

기존의 RAG는 질문이 들어오면 **[검색 → 생성]**이라는 일직선(Linear) 구조로 작동했다. 하지만 질문이 복잡하거나 검색 결과가 나쁘면 답변의 질이 급격히 떨어지는 한계가 있었다.

**에이전틱 RAG**는 여기에 **'판단'**과 **'루프(Loop)'**를 추가한다.

* **자기 비판:** "내가 찾은 정보가 이 질문에 정말 답이 되는가?"
* **재시도:** "정보가 부족하면 검색 쿼리를 수정해서 다시 찾아보자."
* **도구 활용:** "내부 문서에 답이 없다면 구글 검색을 돌려보자."

---

## 2. 구현 방법 1: LangGraph (코드 기반의 정교한 제어)

LangGraph는 LangChain에서 나온 프레임워크로, AI의 사고 과정을 **그래프(Graph)**로 설계한다.

### 핵심 개념

* **Nodes (노드):** 특정 작업 단위 (예: 검색하기, 답변 평가하기, 질문 수정하기)
* **Edges (엣지):** 노드 간의 연결 통로. **'조건부 엣지'**를 통해 다음 단계로 갈지, 이전으로 돌아갈지 결정한다.
* **State (상태):** 전체 과정에서 공유되는 데이터 바구니다.

### 워크플로우 예시 (Self-RAG)

1. **Retrieve:** 벡터 DB에서 관련 문서를 가져온다.
2. **Grade:** LLM이 문서의 관련성을 채점한다.
   * *점수 낮음:* 질문을 다시 쓰고(Rewrite) 1번으로 회귀.
   * *점수 높음:* 다음 단계 진행.
3. **Generate:** 답변 생성 후 '환각(Hallucination)' 여부를 스스로 검증한다.

> **한 줄 요약:** 복잡한 논리 구조와 미세한 커스터마이징이 필요할 때 Python/JS 코드로 구현하는 방식.

---

## 3. 구현 방법 2: n8n (워크플로우 기반의 빠른 자동화)

n8n은 노코드/로코드 툴로, 시각적인 노드 연결을 통해 에이전트를 만든다.

### 핵심 구성 요소

* **AI Agent Node:** 두뇌 역할. 어떤 모델(GPT-4, Claude 등)을 쓸지 정한다.
* **Tools (도구):** 에이전트가 손발처럼 쓸 도구들이다.
  * *Vector Store Tool:* 내부 문서 검색.
  * *Google Search Tool:* 실시간 웹 정보 검색.
* **Memory:** 이전 대화를 기억하게 해주는 노드다.

### 장점

* **시각화:** AI가 어떤 경로로 사고하는지 눈으로 직접 볼 수 있다.
* **확장성:** API 연동이 매우 쉬워, 답변을 바로 디스코드나 슬랙으로 쏘는 기능을 순식간에 붙일 수 있다.

---

## 4. 한눈에 비교하는 도구 선택 기준

| 구분 | LangGraph | n8n |
| --- | --- | --- |
| **난이도** | 높음 (코딩 숙련도 필요) | 낮음 (드래그 앤 드롭) |
| **제어력** | 세밀한 로직 제어 가능 | 제공되는 노드 기능 중심 |
| **배포 속도** | 환경 구축에 시간이 걸림 | 워크플로우 구성 후 즉시 사용 |
| **추천 상황** | 고도화된 AI 서비스 개발 시 | 빠른 프로토타이핑, 서비스 자동화 |

---

## 5. 결론 및 향후 계획

단순한 챗봇을 넘어 **'스스로 교정하는 RAG'**를 만들기 위해서는 흐름(Flow)을 제어하는 능력이 필수적이다.

* 정교한 설계가 필요하다면 **LangGraph**를 깊게 파볼 것.
* 빠르게 기능을 구현하고 다른 서비스와 연동하려면 **n8n**의 AI Agent 노드를 적극 활용할 것.

---

**다음에 해볼 실습:**

* n8n에서 "문서에 답이 없을 때만 구글링하기" 조건부 로직 짜보기
* LangGraph의 `State`를 활용해 대화 맥락 유지하기

---

**[오늘의 한 줄 요약]**
> Naive RAG는 **'일직선'**, Agentic RAG는 **'판단과 루프가 있는 그래프'**다.
> LangGraph는 코드로 정교하게, n8n은 노코드로 빠르게 구현할 수 있다.
