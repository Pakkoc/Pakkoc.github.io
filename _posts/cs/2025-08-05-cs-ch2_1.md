---
title: "[CS] Chapter 2-1. 데이터_0과 1로 숫자를 표현하는 방법"
layout: single
categories:
  - cs
tags:
  - cs
author_profile: false
redirect_from: /cs/number-encoding
sidebar:
  nav: "docs"
search: true
toc: true
toc_sticky: true
toc_label: 목차
toc_icon: "fas fa-microchip"
use_math: true
---

> 📚 **출처**: 강민철 지음, 혼자 공부하는 컴퓨터구조 + 운영체제


## 📊 정보 단위

### 🔢 비트(Bit)
- **컴퓨터가 이해하는 가장 작은 단위** = 비트(bit)
- 1bit에 0 또는 1이 올 수 있음
- **1bit = 2가지의 정보 표현 가능**

### 📈 비트 확장
- **2bit** = 2가지 \* 2가지 = **4가지**의 정보 표현 가능
- **n비트** -> **$2^n$개**의 정보 표현 가능

### 📏 정보 단위 표

| 단위 | 크기 |
|------|------|
| **1바이트(1byte)** | = 8 bit |
| **1킬로바이트(1KB)** | = 1,000 byte |
| **1메가바이트(1MB)** | = 1,000 KB |
| **1기가바이트(1GB)** | = 1,000 MB |
| **1테라바이트(1TB)** | = 1,000 GB |



## 🔢 이진법 (Binary)

### 📝 이진법이란?
**0과 1만으로 모든 숫자를 표현하는 방법**

> 💡 **참고**: 우리가 일반적으로 사용하는 수는 **십진수**로 9를 넘어가는 시점에서 10으로 넘어가는 자리올림이 발생함!!

### 📊 십진수 <-> 이진수 변환

| 십진수 | 이진수 |
|--------|--------|
| 1 | 1 |
| 2 | 1 0 |
| 3 | 1 1 |
| 4 | 1 0 0 |
| 5 | 1 0 1 |
| 6 | 1 1 0 |
| 7 | 1 1 1 |
| 8 | 1 0 0 0 |

### 🔄 이진수 계산 원리

**핵심 규칙**: 십진수의 숫자가 1씩 커질 때마다 이진수의 가장 마지막 자리를 올림

#### 📋 단계별 설명

**1️⃣ 2<sub>(10)</sub>의 이진수**

- 1<sub>(10)</sub> = 1<sub>(2)</sub>
- 2<sub>(10)</sub>는 이진수(1<sub>(2)</sub>)의 마지막 자리인 1에서 올림
- 1을 올림하면 0이 되고 다음 자리수를 올려줌
- **결과**: 마지막자리 0, 그 다음앞에 1 -> **"10<sub>(2)</sub>"**

**2️⃣ 3<sub>(10)</sub>의 이진수**

- 2<sub>(10)</sub> = 10<sub>(2)</sub>
- 이진수(10<sub>(2)</sub>)의 오른쪽 마지막 자리인 0을 올림하면 0은 1이 됨
- **결과**: 1 0 -> 1 1 -> **"11<sub>(2)</sub>"**

**3️⃣ 4<sub>(10)</sub>의 이진수**

- 3<sub>(10)</sub> = 11<sub>(2)</sub>
- 이진수(11<sub>(2)</sub>)의 오른쪽 마지막 자리인 1에서 올림을 해야 함
- 마지막 자리 1에서 올림 -> 마지막 자리는 0
- 그 다음자리 1에 올림을 해줌 -> 그 다음자리 1을 올림하면 0
- 그 다음자리 올림
- **결과**: **"100<sub>(2)</sub>"**



## ➖ 음수 표현

### 🔧 2의 보수법

#### 📖 2의 보수란?
- **사전적 의미**: 어떤 수를 그보다 큰 $2^n$에서 뺀 값
- **실용적 방법**: 모든 0과 1을 뒤집고 거기에 1을 더한 값

#### 🔄 2의 보수 구하는 방법

**예시: 11<sub>(2)</sub>의 2의 보수**

1. **모든 0과 1을 뒤집는다** -> 00<sub>(2)</sub>
2. **거기에 1을 더한다** -> 01<sub>(2)</sub>

#### ⚠️ 문제점과 해결책

**문제**: 컴퓨터가 음수인지 양수인지 구별하기 어려움

**해결책**: 컴퓨터 내부에서는 **플래그(flag)**를 사용

- 이해하기 쉽게 말하면 **부가정보**라고 생각하면 됨



## 🔟 십육진법 (Hexadecimal)

### 📝 십육진법이란?
**수가 15를 넘어가는 시점에서 자리 올림을 하는 숫자 표현 방식**

### 🔢 십육진법 특징
- **16진수를 이루는 숫자 하나**를 이진수로 표현하려면 **4비트**가 필요
- **이유**: $2^4 = 16$이기 때문!

### 📊 십진수<-> 십육진수 변환표

| 십진수 | 0 | 1 | 2 | ... | 10 | 11 | ... | 15 | 16 | 17 |
|--------|---|---|---|-----|----|----|-----|----|----|----|
| 십육진수 | 0 | 1 | 2 | ... | A | B | ... | F | 10 | 11 |

### 🤔 왜 십육진수를 사용할까?

**이진수 <-> 십육진수** 사이의 변환이 **이진수 <-> 십진수** 사이의 변환보다 **훨씬 쉽기 때문**

#### 🔄 변환 방법

**1️⃣ 십육진수 -> 이진수 변환**

- 십육진수를 이루고 있는 **각 글자를 따로따로** 이진수로 변환해서 붙이면 됨

**예시**: 1A2B<sub>(16)</sub>

- 각각의 십육진수 1<sub>(16)</sub>, A<sub>(16)</sub>, 2<sub>(16)</sub>, B<sub>(16)</sub>로 나누어서 이진수로 표현
-  0001<sub>(2)</sub> , 1010<sub>(2)</sub>, 0010<sub>(2)</sub>, 1011<sub>(2)</sub>로 이진수로 각각 표현
- 이걸 붙여서 **0001101000101011<sub>(2)</sub>**로 표현

**2️⃣ 이진수 -> 십육진수 변환**

- 이진수를 **네 개씩 끊어서** 각각 십육진수로 변환한 뒤 붙이면 됨

**예시**: 11010101<sub>(2)</sub>

-  1101<sub>(2)</sub> / 0101<sub>(2)</sub>로 나누기
- 각각 십육진수로 바꾸기 -> D<sub>(16)</sub> / 5<sub>(16)</sub>
- 이걸 붙여서 **D5<sub>(16)</sub>**로 표현


## 💭 느낀점

컴활, ADSP 등 데이터 관련 자격증을 딸 때 항상 나왔던 이진수, 십육진수 변환하는 방법이 항상 책에 있었는데 이 책을 보면서 더욱 쉽게 이해하고 접근할 수 있었음! 그리고 왜 이걸 배우는지 컴퓨터가 받아들이는 이진수를 기준으로 나와있어서 배우면서 내가 코딩하는 것이 대략적으로 어떠한 방식으로 컴퓨터가 인식하고 돌아갈지는 생각해보는 계기가 되었다.
